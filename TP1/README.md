# TP Sextant

## Installation de git
### Windows
* Installer 'Git for Windows' pour avoir git et un shell (git bash)
    * https://gitforwindows.org/
### Ubuntu
* `sudo apt install git`
### MACOS

Il faut installer le gestionnaire de paquet [https://brew.sh/](https://brew.sh/) pour pouvoir récupérer les dépendences logicielles.

#### Installation de brew

Ouvrez un terminal (`CMD` + `Espace` puis entrez `terminal`):
```bash
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
```

vérifier que l'installation a fonctionné en entrant la commande `brew` dans le terminal:
```bash
➜  TP1 git:(master) ✗ brew -v
Homebrew 2.2.10
Homebrew/homebrew-core (git revision 373b0; last commit 2020-03-25)
Homebrew/homebrew-cask (git revision 9949e; last commit 2020-03-25)
```

#### Installation des dépendences logicielles

Dans un terminal entrez la commande suivante pour install QEMU:
```shell
brew install qemu
```

Puis installer les outils de compilation elf avec les commandes suivantes:
```shell
brew tap nativeos/i386-elf-toolchain
brew install i386-elf-binutils i386-elf-gcc
```

## Démarrage avec Visual Studio Code
* Installer l'éditeur de code Visual Studio Code (VS Code)
    * https://code.visualstudio.com/download
* Ouvrir VSCode
* Ouvrir l'exécuteur de commande: `View > Command Palette` ou `Ctrl + Shift + P`
* Entrer 'clone' et exécuter la commande `Git: clone`
* Entrer l'URL `git@github.com:sextant-tpx/TPX.git`
* Installer l'extension 'C/C++'(ms-vscode.cpptools)
    * Ouvrir le panneau extension : `View > Extensions` ou `Ctrl + Shift + X`
    * Entrer 'C/C++' ou 'ms-vscode.cpptools' dans la barre de recherche
    * Cliquer sur `Install`

## Exécution des tâches
* Les tâches sont définies dans `.vscode/tasks.json`
* Exécuter d'une tâche
    * Ouvrir l'exécuteur de commande: `View > Command Palette` ou `Ctrl + Shift + P`
    * Choisir `Run Task`
    * Sélectionner la tâche à exécuter


## Questions TP
### Q2.2
__Quelle signification donnez vous à l’option -tftp ./ de qemu ?__
One of the nice feature of Qemu is its built-in TFTP server. The advantage of using a TFTP server to boot your software is that you do not have to recreate the CD image if something changes. You simple replace the binary to use.
If you want to use the built-in TFTP server specify the -tftp Option. Of course this only enable the TFTP server in Qemu--a boot image is still required. The easiest way is to cat the stage1 and stage2 of Grub together into one image.

### Q2.3
__Le programme s’exécutant dans Qemu boucle indéfiniment : donner les 3 lignes correspondantes__
If the system has nothing more to do, put the computer into an
	infinite loop. To do that:
	1) Disable interrupts with cli (clear interrupt enable in eflags).
	   They are already disabled by the bootloader, so this is not needed.
	   Mind that you might later enable interrupts and return from
	   kernel_main (which is sort of nonsensical to do).
	2) Wait for the next interrupt to arrive with hlt (halt instruction).
	   Since they are disabled, this will lock up the computer.
	3) Jump to the hlt instruction if it ever wakes up due to a
	   non-maskable interrupt occurring or due to system management mode.

```
cli
1:	hlt
jmp 1b
```

### Q3.1
__Faire une copie d'éécran de QEMU.__
`screendump filename.pbm`
Le fichier se trouve dans `build/boot/`

### Q3.2
__Quelle est la valeur retournée par notre premier noyau ?__
_Le registre EIP est utilisé avec le segment du registre CS par le processeur pour connaitre la prochaine instruction à exécuter. Ce registre est donc modifié implicitement par le processeur (instruction suivante, saut à l'adresse indiquée, appel d'une fonction, interruption ...)._
`print $eip`
`xp /3i $eip` -> Display 3 instructions on an x86 processor starting at the current instruction.

__Commencez par déterminer ou son sauvegardé les retours de fonction (dans quel registre). A partir de ce registre, trouver la commande permettant de les afficher. Est-ce la bonne valeur ? Pourquoi ?__
`print $eax`
`xp /1i $eax`
Notre noyau retourne la valeur 0xdeadface correspondant à la valeur hexadecimal de la valeur que l'on retourne : 3735943886. $eax est le registre dans lequel sont stockés nos retours de fonction.
_EAX : registre accumulateur (accumulator register). Utilisé pour les opérations arithmétiques et le stockage de la valeur de retour des appels systèmes._

_Registres :_ https://fr.wikibooks.org/wiki/Programmation_Assembleur/x86/Registres

### Q3.3
__Décompilez le code de notre noyau via l’utilitaire objdump. Faites la même opération via Qemu grâce à la commande xp. Pour rappel le code est dans la section .text__
`objdump build/all-o/main.o -d`
_Response :_
Disassembly of section .text:

00000000 Sextant_main:
       0: 55                            pushl   %ebp
       1: 89 e5                         movl    %esp, %ebp
       3: 83 ec 10                      subl    $16, %esp
       6: c7 45 fc 00 00 00 00          movl    $0, -4(%ebp)
       d: ff 45 fc                      incl    -4(%ebp)
      10: b8 ce fa ad de                movl    $3735943886, %eax
      15: c9                            leave
      16: c3                            retl

`xp /5gi $eip`

### Q3.4
__Suivant l’adresse de début pour le désassemblage le code assembleur affiché n’est pas exactement le même. Pourquoi ?__